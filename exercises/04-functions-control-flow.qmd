
# Controlling flow in function

Conditionals in functions are used to modify how a function runs, determine what output to return or to return warnings and errors depending on logical statements. We'll look at `if` and `else`, as well as functions for combining multiple logical statements. `if` and `else` can be used instead of `stopifnot`, usually in cases where logical statements are more complex or a more elaborate error message is required. 

The following functions are essential for controlling flow in R:

- `if` `else` (and `else if`)
- `||`, `&&` combine multiple logical expressions and short-circuit when `||` sees the first true and `&&` sees the first false
- `|`, `&` are vectorized and cannot be directly used in an if unless you also use `any`, `all`



## Exercises: function conditionals

### Conditional statements

Instruction: Write a series of logical statements for the following objects then consult the solution to check your work. Focus only on the logical statement for now, we'll use `stopifnot` in the following exercises. 

Numeric

- print "positive" if x is greater than 0, else print "negative" if x is less than 0
- check if x is of length 1
- check if x is greater than 0

```{r}
x <- 10
```

<details>
<summary>Show solution</summary>
```{r}
is.numeric(x)
is.integer(x)
is.double(x)

length(x) == 1

x > 0
```
</details>

data.frame

- check if DF is a data.frame, list, matrix
- check if DF has two columns and three rows
- check if DF's column numbers is an integer, double, numeric

```{r}
DF <- data.frame(colors = c('red', 'green', 'blue'), numbers = c(42.1, 2L, 10))
```

<details>
<summary>Show solution</summary>
```{r}
is.data.frame(DF)
is.list(DF)
is.matrix(DF)

ncol(DF) == 2
nrow(DF) == 3

is.integer(DF$numbers)
is.double(DF$numbers)
is.numeric(DF$numbers)
```
</details>


### Writing checks

First, write a function to read a CSV file and prepare it with cleaned column names. Use whichever function you prefer for reading CSVs (eg. `data.table::fread()`, or `readr::read_csv()`). For cleaning column names, we'll use the function `clean_names()` from the `janitor` package. 

Follow the steps from our approach to developing functions:

1. Setup the function
    - Make a function script in the `R/` directory named `prepare_csv.R`
    - Write the function's skeleton (name, arguments, curly braces)
1. Setup the test script
    - Make a corresponding test script in the `tests/` directory named `test_prepare_csv.R`. 
    - Load any required packages (`library(package)`)
    - Source the function (`source('R/function.R)`)
    - Load *example data* and/or arguments for the function 

Note: since we are writing a function to read the data in, we'll test the function with the data's path instead. We'll use the example dataset for adult and chick counts described in the README. For example:

```{r, eval = FALSE}
path_counts <- file.path('raw-data', 'adelie-adult-chick-counts.csv')
```


Add a new section "Development" in the test script (`tests/test_prepare_csv.R`) to develop the body of your function. Use `path_counts` and the function for reading CSVs, then the `clean_names()` function from the `janitor` package. Add the code to your function `prepare_csv()` and test!


<details>
<summary>Hints</summary>
<hr>
This function has two steps: reading a CSV from a path and cleaning the column names. 

Both of these steps are going to use functions from external packages, so we only have to put them together. 

The function's arguments should include the path to the CSV. 

First, take the path and pass it to the function for reading CSVs. 

Then, pass the data.frame returned to the `clean_names()` function from the `janitor` package. 
<hr>
</details>

Now we'll write checks for our `prepare_csv()` function:

- check if the path points to a file that exists
- before returning the object, check that it is a data.frame



- control flow
    - what kinds of arguments might we add to give users options
    - use `if` `then`
    - add `if` `then` statements to above functions
    - add a test for your function that should give different results depending on your conditional statement



